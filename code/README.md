## Code:
The code is organized as follows:
- All of our (programmable) devices are integrated along the I2C bus, so that is a central feature of all the code. 
- The code isn't super pretty. Issues are discussed below. 
- I'm not a CS student so please pardon any other issues you see. Stuff might be implemented in sub-optimal ways (things more important than just the naming), so don't be afraid to change stuff if you're good at microcontroller programming. 

### Things to note: 
- For each device, there's a .h file declaring functions and some constants, and then a .c function implementing all of them.
- The function names aren't great; sorry about that. I'm a bit of a neat freak but never got around to organizing all the function and variable names to follow some nice rules. I would reccomend doing something like the following for naming functions: "device name in camelCase" + "\_" + "purpose of function in camelCase". I meant to do this but ran out of time. And of course, this is your project now and not mine so name your functions however you want.
- Speaking of floats - avoid them at all cost. The MSP (at least our MSP) isn't prepared to handle float operations (pretty sure it just doesn't have hardware for it so it has to do it in software, which ends up being pretty hefty) so they take up a lot of time and energy. Avoiding floats is totally doable, usually just by using large ints. The MSP compiler/IDE (Code Composer Studio) will get mad at you about floats as well as integer multiplication and division, but from what I gather, those aren't nearly as bad as float operations, so I wouldn't worry about those.  
- I2C - I'm currently using [this](https://github.com/jwr/msp430_usi_i2c) I2C library. That github page is great as it explains how to use the code. Most of the I2C communications should be covered in the code that I have written, but this is still good reference. I found it pretty helpful to just throw whatever I2C addresses were necessary for a given device in the corresponding .h file. 
- When I say "normal" LED driver, that's referring to the the non-multiplexed LED drivers (currently driving the LED ring). When I say "numeric" LED driver, that's referring to the multiplexed one that that's driving the numeric displays. 
- In Code Composer Studio you can select different levels of optimization for the compiler to make. These can really reduce the size of the final compiled file that gets put on the micro, so they can be very helpful with the G2452, which doesn't have all that much space. The only downside is that it can make debugging (as in, using CCS to step through the code line by line or function by function no longer an option). There are two ways to play with optimization - one is that there's a setting for speed vs. size (making a tradeoff between the two), and the other is about which sort of optimizations to make. Play around with both. 
- There's a lot of ways to save space and limit energy usage and overall write code that makes the MSP very happy listed [here](http://processors.wiki.ti.com/index.php/Compiler/diagnostic_messages/MSP430/1535). We can probably get by without diving too deep into all of this stuff, but if anyone is very into microcontroller programming this could be something cool to look at. Could also be cool for someone not as into microcontroller programming. 

### Specific Files - 
#### Depth Sensor 
- I don't think this code works, sorry about that. It's pretty close though, there's just some bug I didn't have time to catch because I can't test anything now that I'm not on campus. The depth sensor is interesting; you have to do some processing on the data that the device gives. The datasheet has some description of the processing that needs to happen, and an implementation is provided in code from Sparkfun. I copied this code and modified it just a tad to get rid of floats. Should work. 
- The depth sensor is a little unique in how it reports data. Basically, you send it some data via I2C about what data you want from it, and then it prepares that data, and then you can read it. It's very important to wait while it is preparing the data. The datasheet has info on how long you need to wait while it is doing so ("conversion time"). I was lazy and implemented this with for loops. It would be nicer, but not 100% necessary, to do this with an actuall hardware timer. What would be super nice would be to use a timer, run other code while the timer is running, and then when that other code is done running, check to see if the time is done. If it is done you could then read the prepared data, if not, we could then just wait for the timer be done while not doing anything. 
- You'll see in the "reset" function that I read a bunch of data from the sensor. These are calibration coefficients that are used in processing the data. 
- Note that the raw temperature is necessary in the processing code, that's why I make sure it gets read in the readRawData() function
- I'm pretty sure the calibration coefficients are 2 bytes each while the raw data is three bytes each; that's why I do a bunch of shifting by 8 and 16

#### LED Normal Driver
- You'll see something called "scaled battery voltages". This isn't trivial. What it is is this: It is important for the user to be able to know how much strenth the battery has left in it. In order to do this we feed the battery voltage into one of the ADCs on the micro. First though, we step it down with two resistors, because the battery could be up to 4.2 V, which would hurt the micro. We use very high value resistors for this to minimize current, since this current will be flowing non-stop. Then the ADC turns this voltage into some number between 0 and 1023 (10 bit ADC). Assuming that we're goint to represent the battery voltage with the LED ring (24 LEDs), we need to map this value that is between 0 and 1023 to some number of LEDs between 0 and 24 (inclusive). The way we do this is by picking 24 voltage values, which are somewhere between the lowest and highest values the battery could possibly have. The idea is to space them roughly "evenly" with respect to the capacity percentage the battery has when that is its output voltage. We can't use a linear function because the battery's voltage doesn't change at a constant rate with respect to remaining capacity - look at these "[discharge curves](https://www.google.com/search?biw=1440&bih=794&tbm=isch&sa=1&ei=RcPXW9tXyLGCB8eso4AO&q=lithium+ion+discharge+profile&oq=lithium+ion+discharge+profile&gs_l=img.3...7531.9530..9643...0.0..0.65.1046.18......1....1..gws-wiz-img.......0j0i67j0i8i30j0i24.e8-27WYIB80)" graphs. So anyways, the idea is that we have to take such a graph, split it up into 24 sections, and then take the various values and apply the voltage division and then quantization to them, so we know how to interpret the values the ADC gives us. As in, if the ADC tells us that it's reading "741", we have to turn that into an actual voltage. While we could do all this math in the code on the micro, that would be excessive; it's probably better to just make a lookup table. A made a python script for that ("generateBatteryTables.py"), so that's what that is. 
- About the discharge curves - you'll see that there clearly isn't one graph that fits all lithium-ion batteries, so if we really want to get serious, we should probably make our own, specific to our battery. This wouldn't be to hard. If I'm not mistaken (or more like if Eric is not mistaken, since I'm just copying what he said here), then the new logic analyzer (probably floating around somewhere in the SeaLab) has an analog pin, so we could just hook the battery up to a resistor and attach the logic analyzer's ADC, and then let it sit for a while (but be careful to not let the battery go so low as to hurt itself; maybe do this test after we've made LVC (low voltage cutoff) circuitry). Also, even once we get this curve we probably don't want to represent it 100% truthfully; we probably want to make it so that the system reports that the battery is at 5% when really it's at 10%, and that it's at 1% when really it's at 3% (or something like this) so users freak out and charge it a tad before it's absolutely necessary, just to play it safe (like how your cellphone might be on "2%" for 10 minutes and then on "1%" for two hours). 



